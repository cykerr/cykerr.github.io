<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>每天一个linux命令</title>
      <link href="/2020/04/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/04/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。</p><h3 id="常用参数搭配"><a href="#常用参数搭配" class="headerlink" title="常用参数搭配"></a>常用参数搭配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls -a 列出目录所有文件，包含以.开始的隐藏文件</span><br><span class="line">ls -A 列出除.及..的其它文件</span><br><span class="line">ls -r 反序排列</span><br><span class="line">ls -t 以文件修改时间排序</span><br><span class="line">ls -S 以文件大小排序</span><br><span class="line">ls -h 以易读大小显示</span><br><span class="line">ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>(1) 按易读方式按时间反序排序，并显示文件详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lhrt</span><br></pre></td></tr></table></figure><p>(2) 按大小反序显示文件详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lrS</span><br></pre></td></tr></table></figure><p>(3)列出当前目录中所有以”t”开头的目录的详细内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l t*</span><br></pre></td></tr></table></figure><p>(4) 列出文件绝对路径（不包含隐藏文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | sed &quot;s:^:&#96;pwd&#96;&#x2F;:&quot;</span><br></pre></td></tr></table></figure><p>(5) 列出文件绝对路径（包含隐藏文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find $pwd -maxdepth 1 | xargs ls -ld</span><br></pre></td></tr></table></figure><h2 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a>cd 命令</h2><p>cd(changeDirectory) 命令语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [目录名]</span><br></pre></td></tr></table></figure><p>说明：切换当前目录至 dirName。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>（1）进入根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;</span><br></pre></td></tr></table></figure><p>（2）进入 “home” 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><p>（3）进入上一次工作路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure><p>（4）把上个命令的参数作为cd参数使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd !$</span><br></pre></td></tr></table></figure><h2 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h2><p>pwd 命令用于查看当前工作目录路径。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>（1）查看当前路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p>（2）查看软链接的实际路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd -P</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制中1的个数与补码的一些思考</title>
      <link href="/2020/04/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E4%B8%8E%E8%A1%A5%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2020/04/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E4%B8%8E%E8%A1%A5%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="由一道二进制题目引发的思考"><a href="#由一道二进制题目引发的思考" class="headerlink" title="由一道二进制题目引发的思考"></a>由一道二进制题目引发的思考</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h3 id="解法一：-逐位判断"><a href="#解法一：-逐位判断" class="headerlink" title="解法一： 逐位判断"></a>解法一： 逐位判断</h3><p>逐位判断，这种方式避免了可能出现的死循环，通过 1 &lt;&lt;  i (i从1到31)，逐位和 n 与运算，若该位置有 1 返回 pow(2,i)，否则返回0，只需要统计不为 0 的次数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">思路一： 逐位判断</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># i从1开始左移去找n的二进制表示中对应位置是不是1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        <span class="keyword">if</span> n &amp; (<span class="number">1</span> &lt;&lt; i):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        </span><br><span class="line">  <span class="comment">#（另一种逐位判断方式）n往右移位找1（若不执行下面if操作，对负数会陷入死循环）</span></span><br><span class="line">  <span class="comment"># if n &lt; 0:</span></span><br><span class="line">  <span class="comment">#     n &amp;= 0xffffffff</span></span><br><span class="line">  <span class="comment"># while n:</span></span><br><span class="line">  <span class="comment">#     if n &amp; 1:</span></span><br><span class="line">  <span class="comment">#         count += 1</span></span><br><span class="line">  <span class="comment">#     n &gt;&gt;= 1</span></span><br></pre></td></tr></table></figure><h3 id="解法二：-巧用n-amp-n-1"><a href="#解法二：-巧用n-amp-n-1" class="headerlink" title="解法二： 巧用n&amp;(n-1)"></a>解法二： 巧用n&amp;(n-1)</h3><p>基于一个事实： </p><p>n-1 会向首个有 1 高位借 1 ，该位变成 0，其右边全部变成 1。那么 n &amp; (n-1) 将会使从右往左数的首个 1 变成 0，且该位置左边保持不变，而右边全为0，从而数字 n 的二进制表示中含有几个 1，n &amp; (n-1)的操作便可以执行多少次。另外 n &amp; (n-1) == 0 可以判断 n 是否为 2的 n次幂或者 0（<a href="#n-amp-n-1-0-的含义">参考后文解释</a>）</p><img src="/img/loading.gif" alt="巧用n&amp;(n-1)" style="zoom: 50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/cykerr/CDN/blog/img/20200402173014.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">思路二： 巧用 n&amp;(n-1)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1000 0000 0000 0000 0000 0100 1101 0010 -1234的原码</span></span><br><span class="line">    <span class="comment"># 1111 1111 1111 1111 1111 1011 0010 1110 -1234的补码</span></span><br><span class="line">    <span class="comment"># 1111 1111 1111 1111 1111 1111 1111 1111 补码 0xffffffff (-1)</span></span><br><span class="line">    <span class="comment"># =============================================</span></span><br><span class="line">    <span class="comment"># 因为在python中 bin(-1234)= -0b10011010010，得到的是 1234 的原码加上一个负号</span></span><br><span class="line">    <span class="comment"># -1234 &amp; 0xffffffff 时会使用 -1234 的补码参与位运算，运算结果是一个十六进制数，但在计算机中存放的是其二进制补码</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        n = n &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><hr><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="为什么移位运算和-amp-运算会陷入死循环"><a href="#为什么移位运算和-amp-运算会陷入死循环" class="headerlink" title="为什么移位运算和&amp;运算会陷入死循环"></a>为什么移位运算和&amp;运算会陷入死循环</h3><ol><li>python的整型没有32位限制，当超过32位后会自动转为长整型，而不是截断高位后变为数字0的二进制表示</li><li>python中负数的存储形式和c++/java不同，存的是负号+正数的原码（正数原码=补码）</li></ol><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a = bin(<span class="number">-3</span>)</span><br><span class="line">print(<span class="string">"bin(-3) &gt;&gt;&gt;"</span>, a)</span><br><span class="line"></span><br><span class="line">b = bin(<span class="number">3</span>)</span><br><span class="line">print(<span class="string">"bin(3) &gt;&gt;&gt;"</span>, b)</span><br><span class="line"></span><br><span class="line">c = <span class="number">-3</span> &amp; <span class="number">0xffffffff</span></span><br><span class="line">print(<span class="string">"-3 &amp; 0xffffffff &gt;&gt;&gt;"</span>, c) <span class="comment"># 运算结果是 -3 补码的十六进制数</span></span><br><span class="line"></span><br><span class="line">d = bin(<span class="number">-3</span> &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">print(<span class="string">"bin(-3 &amp; 0xffffffff) &gt;&gt;&gt;"</span>, d)</span><br><span class="line"></span><br><span class="line">e = bin(<span class="number">0xfffffffd</span>)</span><br><span class="line">print(<span class="string">"bin(0xfffffffd) &gt;&gt;&gt;"</span>, e)</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">//bin(<span class="number">-3</span>) &gt;&gt;&gt; <span class="number">-0</span>b11</span><br><span class="line">//bin(<span class="number">3</span>) &gt;&gt;&gt; <span class="number">0b11</span></span><br><span class="line">//<span class="number">-3</span> &amp; <span class="number">0xffffffff</span> &gt;&gt;&gt; <span class="number">4294967293</span></span><br><span class="line">//bin(<span class="number">-3</span> &amp; <span class="number">0xffffffff</span>) &gt;&gt;&gt; <span class="number">0b11111111111111111111111111111101</span></span><br><span class="line">//     bin(<span class="number">0xfffffffd</span>) &gt;&gt;&gt; <span class="number">0b11111111111111111111111111111101</span></span><br></pre></td></tr></table></figure><p>可以看出：</p><ol><li><strong>Python中的整型是补码形式存储的</strong></li><li><strong>Python中<code>bin</code>一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号</strong></li><li><strong>一个负数（十进制表示）&amp; 0xffffffff，输出的是这个负数补码的十六进制表示</strong></li><li><strong>Python中<code>bin</code>一个负数（十六进制表示），输出的是对应的二进制表示（补码），<font color='red'>相当于去掉了负号，Python认为它是一个正数，在位运算时最高位不会补1！</font></strong></li></ol><p>这就导致<strong>十进制负数</strong>在<code>移位运算</code>或 <code>&amp;运算</code>的时候，陷入死循环</p><p>对于<code>移位运算</code>：</p><p>当输入数据n为负数时，每次右移都要向最高位补1，最终陷入0xffffffff死循环。</p><p>对于<code>&amp;运算</code>：</p><p><code>n&amp;(n-1)</code>操作不断消去右边的1，当其补码为 <code>1[31个0]</code>，n-1的补码为<code>0[31个1]</code>，<code>n&amp;(n-1)</code>产生<code>[32个0]</code>，本应结束循环。但n是一个负数，<code>&amp;</code>操作后会在<code>32个0</code>前补一个1，又python整数可以超过32位，不会发生截断，变成<code>1[32个0]</code>这样一个33位整数。并且随着<code>n&amp;(n-1)</code>的操作每次都在溢出位补1，又变成<code>pow(2, 34)</code>、<code>pow(2, 35)</code>…，变成一个越来越大的数字，陷入<code>while n:</code>死循环。</p><p><strong>补充一句</strong>：对于输入的非十进制的数，就是它的补码，计算机是不用再进行补码转换的，直接存入内存。</p><h3 id="n-amp-n-1-0-的含义"><a href="#n-amp-n-1-0-的含义" class="headerlink" title="n&amp;(n-1) == 0 的含义"></a>n&amp;(n-1) == 0 的含义</h3><p>假设 n = 5，二进制表示为101，那么 n-1 = 4，二进制表示为100， 5 &amp; 4 = 101 &amp; 100 = 100 = 4 ！= 0，来看更多的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 &amp; 4 &#x3D; 101 &amp; 100 &#x3D; 4</span><br><span class="line">6 &amp; 5 &#x3D; 110 &amp; 101 &#x3D; 4</span><br><span class="line">7 &amp; 6 &#x3D; 111 &amp; 110 &#x3D; 6</span><br><span class="line">8 &amp; 7 &#x3D; 1000 &amp; 0111 &#x3D; 0</span><br></pre></td></tr></table></figure><p>我们会发现要使表达式等于0，需满足下面条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x + 1 &#x3D; n</span><br><span class="line">x &amp; n &#x3D; 0</span><br></pre></td></tr></table></figure><p>我们来看看有那些数能满足要求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 &amp; 01 &#x3D; 0   -------2^1</span><br><span class="line">100 &amp; 011 &#x3D; 0  -------2^2</span><br><span class="line">1000 &amp; 0111 &#x3D; 0  -------2^3</span><br><span class="line">10000 &amp; 01111 &#x3D; 0  -------2^4</span><br><span class="line">。。。。。。</span><br></pre></td></tr></table></figure><p>所以<code>((n &amp; (n-1)) == 0</code> 的含义是n满足2的n次方，n的最高有效位为1，其余位为0。（或n=0）</p>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原反补码 </tag>
            
            <tag> 进制数 </tag>
            
            <tag> 踩坑记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原码、反码、补码详解</title>
      <link href="/2020/03/31/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/03/31/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h2><p>在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念。</p><h3 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h3><p>一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p><p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p><p>那么，这里的 00000011 和 10000011 就是机器数。</p><h3 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h3><blockquote><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p></blockquote><p>例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p><h2 id="原码-反码-补码的基础概念和计算方法"><a href="#原码-反码-补码的基础概念和计算方法" class="headerlink" title="原码, 反码, 补码的基础概念和计算方法."></a>原码, 反码, 补码的基础概念和计算方法.</h2><p>在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><blockquote><p>[+1]<sub>原</sub> = 0000 0001</p><p>[-1]<sub>原</sub> = 1000 0001</p></blockquote><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><blockquote><p>[1111 1111 , 0111 1111]</p></blockquote><p>即</p><blockquote><p>[-127 , 127]</p></blockquote><p>原码是人脑最容易理解和计算的表示方式.</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码的表示方法是:</p><p>正数的反码是其本身</p><p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p><blockquote><p>[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub></p><p>[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub></p></blockquote><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码的表示方法是:</p><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><blockquote><p>[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub> = [00000001]<sub>补</sub></p><p>[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub> = [11111111]<sub>补</sub></p></blockquote><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p><h2 id="为何要使用原码-反码和补码"><a href="#为何要使用原码-反码和补码" class="headerlink" title="为何要使用原码, 反码和补码"></a>为何要使用原码, 反码和补码</h2><p>在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法.</p><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p><blockquote><p>[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub> = [00000001]<sub>补</sub></p></blockquote><p>所以不需要过多解释. 但是对于负数:</p><blockquote><p>[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub> = [11111111]<sub>补</sub></p></blockquote><p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p><p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p><p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p><p>计算十进制的表达式: 1-1=0</p><blockquote><p>1 - 1 = 1 + (-1) = [00000001]<sub>原</sub> + [10000001]<sub>原</sub> = [10000010]<sub>原</sub> = -2</p></blockquote><p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p><h3 id="为了解决原码做减法的问题-出现了反码"><a href="#为了解决原码做减法的问题-出现了反码" class="headerlink" title="为了解决原码做减法的问题, 出现了反码"></a>为了解决原码做减法的问题, 出现了反码</h3><p>计算十进制的表达式: 1-1=0</p><blockquote><p>1 - 1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub> = [0000 0001]<sub>反</sub> + [1111 1110]<sub>反</sub> = [1111 1111]<sub>反</sub> = [1000 0000]<sub>原</sub> = -0</p></blockquote><p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]<sub>原</sub>和[1000 0000]<sub>原</sub>两个编码表示0.</p><h3 id="补码的出现-解决了0的符号以及两个编码的问题"><a href="#补码的出现-解决了0的符号以及两个编码的问题" class="headerlink" title="补码的出现, 解决了0的符号以及两个编码的问题"></a>补码的出现, 解决了0的符号以及两个编码的问题</h3><blockquote><p>1-1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub> = [0000 0001]<sub>补</sub> + [1111 1111]<sub>补</sub> = [0000 0000]<sub>补</sub>=[0000 0000]<sub>原</sub></p></blockquote><p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p><blockquote><p>(-1) + (-127) = [1000 0001]<sub>原</sub> + [1111 1111]<sub>原</sub> = [1111 1111]<sub>补</sub> + [1000 0001]<sub>补</sub> = [1000 0000]<sub>补</sub></p></blockquote><p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]<sub>原</sub>, 这是不正确的)</p><h3 id="补码还能多表示一个最低数"><a href="#补码还能多表示一个最低数" class="headerlink" title="补码还能多表示一个最低数"></a>补码还能多表示一个最低数</h3><p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p><p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.</p><h2 id="原码-反码-补码-再深入"><a href="#原码-反码-补码-再深入" class="headerlink" title="原码, 反码, 补码 再深入"></a>原码, 反码, 补码 再深入</h2><p>计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?</p><p>将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢?我们可以:</p><blockquote><p>\1. 往回拨2个小时: 6 - 2 = 4</p><p>\2. 往前拨10个小时: (6 + 10) mod 12 = 4</p><p>\3. 往前拨10+12=22个小时: (6+22) mod 12 =4</p></blockquote><p>2,3方法中的mod是指取模操作, 16 mod 12 =4 即用16除以12后的余数是4.</p><p>所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!</p><p>现在的焦点就落在了如何用一个正数, 来替代一个负数. 上面的例子我们能感觉出来一些端倪, 发现一些规律. 但是数学是严谨的. 不能靠感觉.</p><p>首先介绍一个数学中相关的概念: 同余</p><h3 id="同余的概念"><a href="#同余的概念" class="headerlink" title="同余的概念"></a>同余的概念</h3><p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余</p><p>记作 a ≡ b (mod m)</p><p>读作 a 与 b 关于模 m 同余。</p><p>举例说明:</p><blockquote><p>4 mod 12 = 4</p><p>16 mod 12 = 4</p><p>28 mod 12 = 4</p></blockquote><p>所以4, 16, 28关于模 12 同余.</p><h3 id="负数取模"><a href="#负数取模" class="headerlink" title="负数取模"></a>负数取模</h3><p>正数进行mod运算是很简单的. 但是负数呢?</p><p>下面是关于mod运算的数学定义:</p><p><a href="http://images.cnblogs.com/cnblogs_com/zhangziqiu/201103/201103302155507894.jpg" target="_blank" rel="noopener"><img src="/img/loading.gif" alt="clip_image001" class="lazyload" data-src="https://images.cnblogs.com/cnblogs_com/zhangziqiu/201103/201103302155504514.jpg"></a></p><p>上面是截图, “取下界”符号找不到如何输入(word中粘贴过来后乱码). 下面是使用”L”和”J”替换上图的”取下界”符号:</p><blockquote><p>x mod y = x - y L x / y J</p></blockquote><p>上面公式的意思是:</p><p>x mod y等于 x 减去 y 乘上 x与y的商的下界.</p><p>以 -3 mod 2 举例:</p><blockquote><p>-3 mod 2</p><p>= -3 - 2xL -3/2 J</p><p>= -3 - 2xL-1.5J</p><p>= -3 - 2x(-2)</p><p>= -3 + 4 = 1</p></blockquote><p>所以:</p><blockquote><p>(-2) mod 12 = 12-2=10</p><p>(-4) mod 12 = 12-4 = 8</p><p>(-5) mod 12 = 12 - 5 = 7</p></blockquote><h3 id="开始证明"><a href="#开始证明" class="headerlink" title="开始证明"></a>开始证明</h3><p>再回到时钟的问题上:</p><blockquote><p>回拨2小时 = 前拨10小时</p><p>回拨4小时 = 前拨8小时</p><p>回拨5小时= 前拨7小时</p></blockquote><p>注意, 这里发现的规律!</p><p>结合上面学到的同余的概念.实际上:</p><blockquote><p>(-2) mod 12 = 10</p><p>10 mod 12 = 10</p></blockquote><p>-2与10是同余的.</p><blockquote><p>(-4) mod 12 = 8</p><p>8 mod 12 = 8</p></blockquote><p>-4与8是同余的.</p><p>距离成功越来越近了. 要实现用正数替代负数, 只需要运用同余数的两个定理:</p><p>反身性:</p><blockquote><p>a ≡ a (mod m)</p></blockquote><p>这个定理是很显而易见的.</p><p>线性运算定理:</p><blockquote><p>如果a ≡ b (mod m)，c ≡ d (mod m) 那么:</p><p>(1)a ± c ≡ b ± d (mod m)</p><p>(2)a * c ≡ b * d (mod m)</p></blockquote><p>如果想看这个定理的证明, 请看:<a href="http://baike.baidu.com/view/79282.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/79282.htm</a></p><p>所以:</p><blockquote><p>7 ≡ 7 (mod 12)</p><p>(-2) ≡ 10 (mod 12)</p><p>7 -2 ≡ 7 + 10 (mod 12)</p></blockquote><p>现在我们为一个负数, 找到了它的正数同余数. 但是并不是7-2 = 7+10, 而是 7 -2 ≡ 7 + 10 (mod 12) , 即计算结果的余数相等.</p><p>接下来回到二进制的问题上, 看一下: 2-1=1的问题.</p><blockquote><p>2-1=2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反</p></blockquote><p>先到这一步, -1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126.</p><p>发现有如下规律:</p><blockquote><p>(-1) mod 127 = 126</p><p>126 mod 127 = 126</p></blockquote><p>即:</p><blockquote><p>(-1) ≡ 126 (mod 127)</p><p>2-1 ≡ 2+126 (mod 127)</p></blockquote><p>2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1</p><p>所以说一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!</p><p>而2+126很显然相当于钟表转过了一轮, 而因为符号位是参与计算的, 正好和溢出的最高位形成正确的运算结果.</p><p>既然反码可以将减法变成加法, 那么现在计算机使用的补码呢? 为什么在反码的基础上加1, 还能得到正确的结果?</p><blockquote><p>2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补</p></blockquote><p>如果把[1111 1111]当成原码, 去除符号位, 则:</p><blockquote><p>[0111 1111]原 = 127</p></blockquote><p>其实, 在反码的基础上+1, 只是相当于增加了膜的值:</p><blockquote><p>(-1) mod 128 = 127</p><p>127 mod 128 = 127</p><p>2-1 ≡ 2+127 (mod 128)</p></blockquote><p>此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128].</p><p>但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]</p><hr><p>作者：<a href="http://www.cnblogs.com/zhangziqiu/" target="_blank" rel="noopener">张子秋</a><br>出处：<a href="http://www.cnblogs.com/zhangziqiu/" target="_blank" rel="noopener">http://www.cnblogs.com/zhangziqiu/</a> </p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原反补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不够优秀，因为你不够孤独</title>
      <link href="/2020/03/29/%E4%BD%A0%E4%B8%8D%E5%A4%9F%E4%BC%98%E7%A7%80%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BD%A0%E4%B8%8D%E5%A4%9F%E5%AD%A4%E7%8B%AC/"/>
      <url>/2020/03/29/%E4%BD%A0%E4%B8%8D%E5%A4%9F%E4%BC%98%E7%A7%80%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BD%A0%E4%B8%8D%E5%A4%9F%E5%AD%A4%E7%8B%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="节选自网络"><a href="#节选自网络" class="headerlink" title="节选自网络"></a>节选自网络</h1><p>人生来孤独，因而也惧怕孤独，很少有人能够真正坦然的面对孤独。多数的人是在寻找孤独与群居之间的一种平衡。但这种平衡靠什么来掌握呢？靠心，心觉得孤独了，才想去平衡一下，但本质上还是惧怕孤独。金庸小说里的不少武林高手有不少是喜欢孤独的，也在孤独中创造了不少精湛武学。例如张三丰，闭关思考，悟出以柔克刚的太极拳与太极剑，终成一代宗师。当一个人真正孤独地面对自己，开始思考时，这个人就开始成熟了，才有了创造的可能性。</p><p>各种励志书籍都在鼓励人去交往，去建立关系，但很少有书叫人去孤独，这也是我不喜欢看励志书的原因。强调行动力本身并没有错，但是没有经过孤独思考的行动力是不是值得去学习呢？</p><p>人在社会中生存，就很难做到孤独，每天都要接触不少的人与事，哪有时间去孤独？一到夜晚，本来是面对孤独的时候，却把时间交给了电话与网络。我时常觉得电脑的产生让人越来越没有思想了，想象力更加的贫乏了。一有时间就在网上，寄希望在网上学到多少东西，但真学了多少东西呢？</p><p>每个人都希望自己优秀，但似乎每个人都不愿意去孤独。这个年代，很多人憧憬的是物质、名誉与享受，却很少去关心自己的内心需要的什么。真正优秀的人往往觉得自己是孤独的，也会认为自己的优秀来源于自己的孤独。苏东坡是孤独的，所以才有了后来的大江东去的千古名作，司马迁是孤独的，所以才有了「史家之绝唱，无韵之离骚」之称的《史记》，爱因斯坦是孤独的，所以才有了相对论。大师往往是孤独的，对他来的人生来说，可能并一定是幸事，但却是时代的幸事。上天往往就是这么公平！</p><p>看一个人优秀不优秀，我觉得其实只要看他在孤独的时候是在做什么，是手无足措，还是镇定自若？是折腾还是享受？优秀的人往往在自己的心中有那么一段或几段孤独的时光，可能并不愿意再去重复，但却愿意让那种回忆停留在记忆的某一处，不轻易说，但却是自信的根基。我自信，因为我孤独过。</p><p>走在前往优秀路上的人，往往觉得自己太孤独了，自己的优秀并没有被人所知，所以有人选择了退却，选择了随大流，其实也就选择了远离优秀，因为优秀诞生了思考，思考又常与孤独为伴。</p><p>你够优秀吗？请先问问你自己：你够孤独吗？</p>]]></content>
      
      
      <categories>
          
          <category> 杂文收录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人的生活方式有两种</title>
      <link href="/2020/03/29/%E4%BA%BA%E7%9A%84%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%A4%E7%A7%8D/"/>
      <url>/2020/03/29/%E4%BA%BA%E7%9A%84%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%A4%E7%A7%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="节选自俞洪敏励志演讲"><a href="#节选自俞洪敏励志演讲" class="headerlink" title="节选自俞洪敏励志演讲"></a>节选自俞洪敏励志演讲</h1><p>人的生活方式有两种，第一种是像草一样活着。你尽管活着，每年还在成长，但是你毕竟是一颗草；你吸收雨露阳光，但是长不大。人们可以踩过你，人们不会因为你的痛苦而产生痛苦；人们不会因为你被踩了，而来怜悯你，因为人们本身就没看到你。所以，我们每一个人都应该像树一样成长。即使我们现在什么都不是，但是只要你有树的种子，即使被人踩到泥土中间，你依然能够吸收泥土的养分，自己成长起来。也许两年、三年你长不大，但是十年、八年、二十年，你一定能长成参天大树，当你长成参天大树以后，遥远的地方，人们就能看到你；走近你，你能给人一片绿色、一片阴凉，你能帮助别人。即使人们离开你以后，回头一看，你依然是地平线上一道美丽的风景线。树，活着是美丽的风景，死了依然是栋梁之才。活着死了都有用，这就是我们每一个同学做人的标准和成长的标准。</p><p>当一个人为别人活着的时候，就非常麻烦。因为别人的标准是不一样的，没有坚持了自己的追求而想要的东西，你的尊严和自尊是得不到保证的，因为你总是在飘摇中间。对于我们来说，保持自己尊严和自尊的最好的方法是什么呢？就是说你有一个梦想，通过从最基本的一个步骤，你就可以开始追求。比如说最后你想取代我，成为新东方的董事长和总裁，你能不能做到？只要你有足够的心态和足够做事情的方法，以及胸怀，肯定是能做到的。</p><p>凡是想要一下子把一件事情干成的人，就算他干成这件事情，他也没有基础，因为等于是在沙滩上造的房子，最后一定会倒塌。只有慢慢地一步一步把事情干成的，每一步都给自己打下坚实的基础，每一步都给自己一个良好的交代，再重新向未来更高去走每一步的人，他才能够把事情真正地做成功。</p><p>当你决定了一辈子干什么以后，你就要坚定不移地干下去，就不要随便地换。你可以像一条河流一样，越流越宽阔，但是千万不要再想去变成另外一条河，或者变成一座高山。有了这样一个目标以后，你生命就不会摇晃，不会因为有某种机会，你就到处乱窜，这样你才能够做出事情。</p><p>我们未来生活的一种重要能力，叫做忍辱负重的能力。很多社会名流会遇到很多很多你不能忍受的事情，但是你不得不忍受。而你不忍受就不可能成功。为什么，因为你不忍辱负重，你就没有时间，你就没有空间，没有走向未来的空间。如果你想走向未来，最后变得更加强大、更加繁荣，你就必须要做好给自己留下足够的时间和空间。轮到我们自己的生命，要想为一个伟大的目标而奋斗的时候，你排除也得必须排除，你生命中一切琐碎的干扰，因此你就必须忍辱负重。</p><p>不管我们是什么年龄，我们哪能做一时气不过的事情。这个世界上让你气不过的事情太多了，只有你气得过的时候，这个世界才在你面前才能展开最光辉的一面。</p><p>我有这么一个比喻，每一条河流都有自己不同的生命曲线。长江和黄河的曲线，是绝对不一样的。但是每一条河流都有自己的梦想，那就是奔向大海。所以不管黄河是多么的曲折，绕过了多少的障碍；长江拐的弯不如黄河多，但是她冲破了悬崖峭壁，用的方式是不一样的，但是最后都走到了大海。当我们遇到困难时，不管是冲过去还是绕过去，只要我们能过去就行。我希望大家能使自己的生命向梦想流过去，像长江、黄河一样流到自己梦想的尽头，进入宽阔的海洋，使自己的生命变得开阔，使自己的事业变得开阔。但是并不是你想流就能流过去，其实这里面就具备了一种精神，毫无疑问就是水的精神。我们的生命有时候会是泥沙，尽管你也跟着水一起往前流，但是由于你个性的缺陷，面对困难的退步或者说胆怯，你可能慢慢地就会像泥沙一样沉淀下去，一旦你沉淀下去，也许你不用为前进而努力了，但是你却永远见不得阳光了。你沉淀了下去，上面的泥沙就会不断地把你压住，最后你会暗无天日。所以我建议大家，不管你现在的生命是什么样的，一定要有水的精神。哪怕被污染了，也能洗净自己。像水一样，不断地积蓄自己的力量，不断地冲破障碍，当你发现时机不到的时候，把自己的厚度给积累起来，当有一天时机来临的时候，你就能够奔腾入海，成就自己的生命。</p><p>渡过难关是一种心态，你想要跨过去的话，就必然能跨过去。</p><p>很多人在工作的时候，带着怨气和怨恨在工作，你的工作就远做不好。</p><p>如何能够把事情做得更成功的几个要点。第一要点，如何尽可能把自己的长期目标和短期目标结合起来。我们要先分清楚，哪些事情是我们想一辈子干的事情，哪些事情是一下子干完，我们就可以不用干的事情。中国有句话叫急事慢做，你越着急的事情，你做的越仔细、越认真，越能把事情做好。而你越着急的事情，做的越快反而越做的七零八落，我把这个急事也叫做大事。第二个要素就是要决定自己一辈子干什么。那么还有一个我觉得非常重要的，就是平时做事情的时候，对时间的计划性。还有一点，就是成功要自我约束。任何时候，当你前面面临一个巨大的诱惑，和其它任何可能产生诱惑的时候，如果你觉得自己停不下来，你千万别去追那个东西。因为你追了那个东西停不下来，最后栽跟头的一定就是你。</p><p>千万记住一点，做任何事情的时间都是能挤出来的。</p><p>伟大与平凡的不同之处，一个平凡的人每天过着琐碎的生活，但是他把琐碎堆砌出来，还是一堆琐碎的生命。所谓伟大的人，是把一堆琐碎的事情，通过一个伟大的目标，每天积累起来以后，变成一个伟大的事业。</p><p>我的核心价值观就是，以善为生，用善良的心态来对待自己的生命和别人的生命。</p><p>有两句话我是比较欣赏的。生命是一种过程；事业一种结果。</p><p>我们每一个人是活在每一天的，假如说你每一天不高兴，你把所有的每一天都组合起来，就是你一辈子不高兴。但是假如你每一天都高兴了，其实你一辈子就是幸福快乐的。有一次我在往黄河边上走的时候，我就用矿泉水瓶灌了一瓶水。大家知道黄河水特别的浑，后来我就放在路边，大概有一个小时左右。让我非常吃惊的发现，四分之三已经变成了非常清澈的一瓶水，而只有四分之一呢，是沉淀下来的泥沙。假如说我们把这瓶水，清水部分比喻我们的幸福和快乐，而把那个浑浊的那个沉淀的泥沙，比喻我们痛苦的话，你就明白了；当你摇晃一下以后，你的生命中整个充满的是浑浊，也就是充满的都是痛苦和烦恼。但是当你把心静下来的以后，尽管泥沙总的份量一点都没有减少，但是它沉淀在你的心中，因为你的心比较沉静，所以就再也不会被搅和起来，因此你的生命的四分之三，就一定是幸福和快乐的。</p><p>人的生命道路其实很不平坦，靠你一个人是绝对走不完的，这个世界上只有你跟别人在一起，为了同一个目标一起做事情的时候，才能把这件事情做成。一个人的力量很有限，但是一群人的力量是无限的。当五个手指头伸出来的时候，它是五个手指头，但是当你把五个手指头握起来的时候，它是一个拳头。未来除了是你自己成功，一定要跟别人一起成功，跟别人团结在一起，形成我们，你才能把事情做成功。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文收录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型评估</title>
      <link href="/2020/03/25/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/"/>
      <url>/2020/03/25/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>没有测量，就没有科学。</p></blockquote><h1 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h1>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 模型评估 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征工程</title>
      <link href="/2020/03/25/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
      <url>/2020/03/25/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特征工程，顾名思义，是对原始数据进行一系列工程处理，将其提炼为特征，作为输入供算法和模型使用 。 从本质上来讲，特征工程是一个表示和展现数据的过程 。 在实际工作中，特征工程旨在去除原始数据中的杂质和冗余，设计更高效的特征以刻画求解的问题与预测模型之间的关系 。</p></blockquote><h1 id="特征归一化"><a href="#特征归一化" class="headerlink" title="特征归一化"></a>特征归一化</h1><h2 id="线性函数归一化"><a href="#线性函数归一化" class="headerlink" title="线性函数归一化"></a>线性函数归一化</h2><h2 id="零均值归一化"><a href="#零均值归一化" class="headerlink" title="零均值归一化"></a>零均值归一化</h2><p>对数值类型的特征做归一化可以将所有的特征都统一到一个大致相同的数值区间内。减小不同纬度数值特征的差异性，这样可以更快地通过梯度下降找到最优解。</p><h1 id="文本表示模型"><a href="#文本表示模型" class="headerlink" title="文本表示模型"></a>文本表示模型</h1><h2 id="词袋模型和N-gram模型"><a href="#词袋模型和N-gram模型" class="headerlink" title="词袋模型和N-gram模型"></a>词袋模型和N-gram模型</h2><h2 id="词嵌入与深度学习模型"><a href="#词嵌入与深度学习模型" class="headerlink" title="词嵌入与深度学习模型"></a>词嵌入与深度学习模型</h2><h1 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h1>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 特征工程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
